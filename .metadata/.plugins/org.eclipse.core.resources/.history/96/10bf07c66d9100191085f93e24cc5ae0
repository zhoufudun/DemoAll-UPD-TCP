/**
 * æµ‹è¯•
 */
package com;

import java.net.InetSocketAddress;

import io.netty.bootstrap.Bootstrap;
import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.DatagramPacket;
import io.netty.channel.socket.nio.NioDatagramChannel;
import test.TestClient;


/**
 *
 * @author beykery
 */
public abstract class KcpClient implements Output, KcpListerner, Runnable
{

    private final NioDatagramChannel channel;
    private final InetSocketAddress addr;
    private int nodelay;
    private int interval = Kcp.IKCP_INTERVAL;
    private int resend;
    private int nc;
    private int sndwnd = Kcp.IKCP_WND_SND;
    private int rcvwnd = Kcp.IKCP_WND_RCV;
    private int mtu = Kcp.IKCP_MTU_DEF;
    private int conv = (int) (Math.random() * Integer.MAX_VALUE);
    private boolean stream;
    private int minRto = Kcp.IKCP_RTO_MIN;
    private long timeout;
    private KcpOnUdp kcp;
    private volatile boolean running;
    private static final Object waitLock = new Object();//åŠ é”
    private InetSocketAddress remote;
    private NioEventLoopGroup nioEventLoopGroup;

    /**
     * client
     */
    public KcpClient()
    {
        this(0);
    }

    /**
     * å®¢æˆ·ç«?
     * è®¾ç½®æœ¬æœºç«¯å£port
     * @param port
     */
    public KcpClient(int port)
    {
    	System.out.println(port);
    	// Bootstrapï¼Œç”¨äºé…ç½®å®¢æˆ·ç«¯ï¼Œè¿™é‡Œé…ç½®æˆNioDatagramChannelé€šé“
        nioEventLoopGroup = new NioEventLoopGroup();//ä¸?ç›´å¾ªç?
        Bootstrap bootstrap = new Bootstrap();
        bootstrap.channel(NioDatagramChannel.class);//NioDatagramChannel, å¼‚æ­¥çš? UDP è¿æ¥
        bootstrap.group(nioEventLoopGroup);
        //æŒ‡å®šChannelHandler
        bootstrap.handler(new ChannelInitializer<NioDatagramChannel>()
        {
        	//æŒ‡å®šChannelHandler
            @Override
            protected void initChannel(NioDatagramChannel ch) throws Exception
            {
            	//æ·»åŠ å®‰å…¨å¥—æ¥å­—å¤„ç†å™¨å’Œé?šé“å¤„ç†å™?
                ChannelPipeline cp = ch.pipeline();
                //ChannelHandler ç”¨æ¥å¤„ç†ç½‘ç»œè¯·æ±‚å†…å®¹,
                //ChannelInboundHandlerå’ŒChannelOutboundHandlerä¸¤ç§ï¼?
                //ChannlPipelineä¼šä»å¤´åˆ°å°¾é¡ºåºè°ƒç”¨ChannelInboundHandlerå¤„ç†ç½‘ç»œè¯·æ±‚å†…å®¹ï¼?
                //ä»å°¾åˆ°å¤´è°ƒç”¨ChannelOutboundHandlerå¤„ç†ç½‘ç»œè¯·æ±‚å†…å®¹ã€‚è¿™ä¹Ÿæ˜¯Nettyç”¨æ¥çµæ´»å¤„ç†ç½‘ç»œè¯·æ±‚çš„æœºåˆ¶ä¹‹ä¸?. 
                /*
                 * åœ¨Nettyæä¾›äº†ä¸€ä¸ªChannelInboundHandlerAdapterå­ç±»ï¼ŒChannelInitializerã€?
                 * é€šè¿‡è¿™ä¸ªå¯ä»¥å°†å¤šä¸ªHandleræ·»åŠ åˆ°ä¸€ä¸ªChannelPipelineä¸­ã??
                 * åœ¨æ·»åŠ çš„è¿‡ç¨‹ä¸­ï¼Œéœ?è¦æ³¨æ„ChannelHandlerçš„æ·»åŠ é¡ºåºã??
                 * å°†ä¸€äº›æ•°æ®æ¢³ç†çš„Handleræ”¾åœ¨å‰é¢ï¼Œä¸šåŠ¡å¤„ç†çš„åˆ™æ”¾åœ¨æœ€åã??
                 * ä¾‹å¦‚HttpæœåŠ¡ï¼Œéœ€è¦å…ˆå°†Nettyçš„TCPæ•°æ®å°è£…æˆå¯¹åº”çš„HttpRequestä¹‹åæˆ‘ä»¬æ‰èƒ½æ–¹ä¾¿ä½¿ç”¨ã€?
                 */
                cp.addLast(new KcpClient.UdpHander());
            }
        });
        //ç»‘å®šæ–¹æ³•#bindå¯¹æ— è¿æ¥çš„æŠ¥æ–‡é?šä¿¡UDPéå¸¸æœ‰ç”¨ã€‚å¯¹äºSocketè¿æ¥TCPï¼Œå¯ä»¥ä½¿ç”?#connectè¿æ¥æ–¹æ³•ã€?
        //syncUninterruptibly()è®©ä¸»çº¿ç¨‹åŒæ­¥ç­‰å¾…å­çº¿ç¨‹ç»“æ?
        //å¼?å§‹ç»‘å®šserver
        //é€šè¿‡è°ƒç”¨syncåŒæ­¥æ–¹æ³•ï¼Œé˜»å¡ç›´åˆ°ç»‘å®šæˆåŠ?
        //é€šé“ç»‘å®šç«¯å£ï¼Œå¼€å¯ç›‘å¬ï¼ŒåŒæ­¥ç­‰å¾…ç›´åˆ°ç»‘å®šæˆåŠŸ      
	    ChannelFuture sync = bootstrap.bind(port).syncUninterruptibly();   
        channel = (NioDatagramChannel) sync.channel();//è¿”å›ç»‘å®šçš„é?šé“
        ////3 è®¾ç½®ç›‘å¬ç«¯å£ï¼Ÿï¼Ÿï¼Ÿï¼Ÿ
        addr = channel.localAddress(); //è¿”å›ç»‘å®šæˆåŠŸçš„åœ°å?InetSocketAddress
        System.out.println("æœ¬æœºç«¯å£ï¼?"+addr.getPort() +" æœ¬æœºipï¼? "+addr.getHostName());
        /*
         * è¿™ä¸ªæ–¹æ³•çš„ä½œç”¨å°±æ˜¯åœ¨JVMä¸­å¢åŠ ä¸€ä¸ªå…³é—­çš„é’©å­ã€?
         * å½“ç¨‹åºæ­£å¸¸é??å‡ºã?ç³»ç»Ÿè°ƒç”? System.exitæ–¹æ³•æˆ–è?…è™šæ‹Ÿæœºè¢«å…³é—­æ—¶æ‰ä¼šæ‰§è¡Œç³»ç»Ÿä¸­å·²ç»è®¾ç½®çš„æ‰?æœ‰é’©å­ï¼Œ
         * å½“ç³»ç»Ÿæ‰§è¡Œå®Œè¿™äº›é’©å­åï¼ŒJVMæ‰ä¼šå…³é—­ã€?
         * æ‰?è°“é’©å­ï¼Œå°±æ˜¯ä¸?ä¸ªå·²åˆå§‹åŒ–ä½†å¹¶ä¸å¯åŠ¨çš„çº¿ç¨?
         * 
         * jvmä¸­å¢åŠ ä¸€ä¸ªå…³é—­çš„é’©å­ï¼Œå½“jvmå…³é—­çš„æ—¶å€™ï¼Œä¼šæ‰§è¡Œç³»ç»Ÿä¸­å·²ç»è®¾ç½®çš„æ‰€æœ‰é?šè¿‡æ–¹æ³•addShutdownHookæ·»åŠ çš„é’©å­ï¼Œ
         * å½“ç³»ç»Ÿæ‰§è¡Œå®Œè¿™äº›é’©å­åï¼Œjvmæ‰ä¼šå…³é—­ã€‚æ‰€ä»¥è¿™äº›é’©å­å¯ä»¥åœ¨jvmå…³é—­çš„æ—¶å€™è¿›è¡Œå†…å­˜æ¸…ç†ã?å¯¹è±¡é”€æ¯ç­‰æ“ä½œ
         */
        Runtime.getRuntime().addShutdownHook(new Thread(new Runnable()
        { 
            public void run()
            {   //å…³é—­æˆ–æœ‰æ´»åŠ¨çš„çº¿ç¨?
                nioEventLoopGroup.shutdownGracefully();
            }
        }));
    }

    /**
     * fastest: ikcp_nodelay(kcp, 1, 20, 2, 1) nodelay: 0:disable(default),
     * 1:enable interval: internal update timer interval in millisec, default is
     * 100ms resend: 0:disable fast resend(default), 1:enable fast resend nc:
     * 0:normal congestion control(default), 1:disable congestion control
     *
     * @param nodelay
     * @param interval
     * @param resend
     * @param nc
     */
    public void noDelay(int nodelay, int interval, int resend, int nc)
    {
        this.nodelay = nodelay;
        this.interval = interval;
        this.resend = resend;
        this.nc = nc;
    }

    /**
     * set maximum window size: sndwnd=32, rcvwnd=32 by default
     *
     * @param sndwnd
     * @param rcvwnd
     */
    public void wndSize(int sndwnd, int rcvwnd)
    {
        this.sndwnd = sndwnd;
        this.rcvwnd = rcvwnd;
    }

    /**
     * change MTU size, default is 1400
     *
     * @param mtu
     */
    public void setMtu(int mtu)
    {
        this.mtu = mtu;
    }

    /**
     * conv
     *
     * @param conv
     */
    public void setConv(int conv)
    {
        this.conv = conv;
    }

    /**
     * stream mode
     *
     *
     * @param stream
     */
    public void setStream(boolean stream)
    {
        this.stream = stream;
    }

    public boolean isStream()
    {
        return stream;
    }

    public void setMinRto(int minRto)
    {
        this.minRto = minRto;
    }

    public void setTimeout(long timeout)
    {
        this.timeout = timeout;
    }

    public long getTimeout()
    {
        return this.timeout;
    }

    /**
     * å›ºå®šè¿æ¥åˆ°ä¸€ä¸ªæœåŠ¡å™¨åœ°å€,åªä¼šå¤„ç†æ­¤åœ°å?çš„æ¶ˆæ?
     *
     * @param addr
     */
    public void connect(InetSocketAddress addr)
    {
        this.remote = addr;//è¿œç«¯åœ°å€
        this.channel.connect(addr);//ç»‘å®šè¿œç«¯åœ°å€
    }

    
    public void out(ByteBuf msg, Kcp kcp, Object user)
    {
        DatagramPacket temp = new DatagramPacket(msg, (InetSocketAddress) user, this.addr);
        this.channel.writeAndFlush(temp);
    }

    
    public void handleClose(KcpOnUdp kcp)
    {
        this.close();
    }

    /**
     * æ”¶åˆ°æœåŠ¡å™¨æ¶ˆæ?
     *
     * @param dp
     */
    private void onReceive(DatagramPacket dp)
    {
        if (this.kcp != null && this.running)
        {
            this.kcp.input(dp.content());
            //
            //System.out.println("æœåŠ¡å™¨å›å¤?");
            //
            synchronized (this.waitLock)
            {
                this.waitLock.notify();
            }
        } else
        {
            dp.release();
        }
    }

    /**
     * å…³æ‰
     *
     */
    public void close()
    {
        if (this.running)
        {
            this.running = false;
        }
    }

    /**
     * å‘é?æ¶ˆæ?
     *
     * @param bb
     */
    public void send(ByteBuf bb)
    {
        if (this.kcp != null)
        {
            this.kcp.send(bb);
            synchronized (this.waitLock)
            {
                this.waitLock.notify();
            }
        }
    }

    /**
     * å¼?å¯çº¿ç¨‹å¤„ç†kcpçŠ¶æ??
     */
    public void start()
    {
        if (!this.running)
        {
            this.running = true;
            this.kcp = new KcpOnUdp(this, remote, addr, this);
            this.kcp.noDelay(nodelay, interval, resend, nc);
            this.kcp.wndSize(sndwnd, rcvwnd);
            this.kcp.setTimeout(timeout);
            this.kcp.setMtu(mtu);
            this.kcp.setConv(conv);
            this.kcp.setStream(stream);
            this.kcp.setMinRto(minRto);
            Thread t = new Thread(this);
            t.setName("kcp client thread");
            t.start();
        }
    }
    //ä¿®æ”¹åçš„ç¨‹åºå¦‚ä¸‹
   
    public void run()
    {
        long start, end;
        while (running)
        {
        	synchronized (waitLock) //åŠ é”Objectå¯¹è±¡
            {
	            start = System.currentTimeMillis();//å¼?å§‹æ—¶é—?
	            if (kcp.isClosed()) //kcpå…³é—­
	            {
	                this.running = false;
	                continue;//è·³å‡ºwhileå¾ªç¯
	            }
	            kcp.update(); //
	            end = System.currentTimeMillis();//ç»“æŸæ—¶é—´
	            if (end - start <interval) //è®¾ç½®åˆ·æ–°æ—¶é—´10MS
	            {                
	                try
	                {
	                	//waitä¼šé‡Šæ”¾é”
	                    //ç›´åˆ°å…¶ä»–çº¿ç¨‹è°ƒç”¨æ­¤å¯¹è±¡çš„ notify() æ–¹æ³•æˆ? notifyAll() æ–¹æ³•â€ï¼Œå½“å‰çº¿ç¨‹è¢«å”¤é†?(è¿›å…¥â€œå°±ç»ªçŠ¶æ€â??)
	                    waitLock.wait(interval - end + start);//ç›´åˆ°æ—¶é—´å·®ä¸º10MS???
	                } catch (InterruptedException ex){
	                    ex.printStackTrace();
	                }	                
	            }
            }
        }      
        this.release();//é‡Šæ”¾å†…å­˜
        nioEventLoopGroup.shutdownGracefully();//å…³é—­çº¿ç¨‹
        this.channel.close();//å…³é—­é€šé“
    }
    /*
     * åŸæœ¬çš„ç¨‹åºå¦‚ä¸?
      @Override
    public void run()
    {
        long start, end;
        while (running)
        {
        	
	            start = System.currentTimeMillis();//å¼?å§‹æ—¶é—?
	            if (kcp.isClosed()) //kcpå…³é—­
	            {
	                this.running = false;
	                continue;//è·³å‡ºwhileå¾ªç¯
	            }
	            kcp.update(); //
	            end = System.currentTimeMillis();//ç»“æŸæ—¶é—´
	            if (end - start <interval) //è®¾ç½®åˆ·æ–°æ—¶é—´10MS
	            {   
	            	synchronized (waitLock) //åŠ é”Objectå¯¹è±¡
            		{             
		                try
		                {
		                	//waitä¼šé‡Šæ”¾é”
		                    //ç›´åˆ°å…¶ä»–çº¿ç¨‹è°ƒç”¨æ­¤å¯¹è±¡çš„ notify() æ–¹æ³•æˆ? notifyAll() æ–¹æ³•â€ï¼Œå½“å‰çº¿ç¨‹è¢«å”¤é†?(è¿›å…¥â€œå°±ç»ªçŠ¶æ€â??)
		                    waitLock.wait(interval - end + start);//ç›´åˆ°æ—¶é—´å·®ä¸º10MS???
		                } catch (InterruptedException ex){
		                    ex.printStackTrace();
		                }
		            }	                
	            }    
        }      
        this.release();//é‡Šæ”¾å†…å­˜
        nioEventLoopGroup.shutdownGracefully();//å…³é—­çº¿ç¨‹
        this.channel.close();//å…³é—­é€šé“
    }
     
     */

    /**
     * é‡Šæ”¾å†…å­˜
     */
    private void release()
    {
        this.kcp.release();
    }
    /**
     * è‡ªå®šä¹‰Hander å†…éƒ¨ç±?
     */
    public class  UdpHander extends ChannelInboundHandlerAdapter{
    	//å¤„ç†æ”¶åˆ°çš„å†…å®?
        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
        {
            DatagramPacket dp = (DatagramPacket) msg;
            KcpClient.this.onReceive(dp);
        }
        //å¤„ç†å¼‚å¸¸
        @Override
        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception
        {
            KcpClient.this.handleException(cause, null);
            KcpClient.this.close();
        }
    }
}
